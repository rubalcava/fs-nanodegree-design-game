Q. What additional properties did you add to your models and why?	I had to add quite a few new properties to each of the models in order to implement the new functionality Hangman required. 	The User model was given: total_game_score (sum of all finished game scores), total_games_played (sum of all finished games), and user_score (proprietary score used to rank user against other players). These properties were required to implement the get_user_rankings endpoint.	The Game model was given: obscured_target (the target word with its letters hidden), tried_letters_were_wrong (to keep track of wrong guesses), correct_letters (to keep track of correct guesses), and all_guesses (to keep track of all guesses). The first property was required to implement the very essence of the game, which is guessing and revealing hidden letters in a word. The rest of the properties were required to implement the get_game_history endpoint.	The Score model was given: game_score (proprietary score based on guesses left and the length of the word). This was required to implement a scoring system, which was required to implement the get_high_scores and get_user_rankings endpoints.	Aside from the models, I had to modify some of the existing forms and resource containers, as well as add new ones, the reasons for which are explained in the next question.Q. What were some of the trade-offs or struggles you faced when implementing the new game logic?	When building Hangman, I struggled with the forms. Primarily, I wanted to reuse the same forms to reduce the complexity of my code, but sometimes the fields just didn’t make sense for the api endpoint that would be returning it. Therefore, I had to write new forms and resource containers.    	The next issue I faced was the complexity of the game logic in make_move. Due to the way I decided to count (and not count) moves, I had to use a lot of “if… else…” statements. It began looking like spaghetti code. In an effort to make it more readable, I added plenty of comments explaining exactly what was going on.	The issue that frustrated me that most, however, was the api explorer itself. Sometimes, it kept running old code instead of updated code, so there were times when my code would fail over and over until I refreshed my browser and tried again. I eventually learned to refresh after every code change, but it was still a big annoyance.	